
def calc_f1(y_true, y_pred):
    if not FLAGS.sigmoid:
        # Converti le etichette one-hot encoded in indici di classe
        y_true = np.argmax(y_true, axis=1)
        y_pred = np.argmax(y_pred, axis=1)
    else:
        # Converti le probabilità in etichette binarie
        y_pred[y_pred > 0.5] = 1
        y_pred[y_pred <= 0.5] = 0
        
    return metrics.f1_score(y_true, y_pred, average="micro"), metrics.f1_score(y_true, y_pred, average="macro"), metrics.f1_score(y_true, y_pred, average="weighted")

def calc_accuracy(y_true, y_pred):
    if not FLAGS.sigmoid:
        # Converti le etichette one-hot encoded in indici di classe
        y_true = np.argmax(y_true, axis=1)
        y_pred = np.argmax(y_pred, axis=1)
    else:
        # Converti le probabilità in etichette binarie
        y_pred[y_pred > 0.5] = 1
        y_pred[y_pred <= 0.5] = 0
    
    return metrics.accuracy_score(y_true, y_pred)

def calc_AUPRC(y_true, y_pred):
    if not FLAGS.sigmoid:
        # Converti le etichette one-hot encoded in indici di classe
        y_true = np.argmax(y_true, axis=1)
        y_pred = np.argmax(y_pred, axis=1)
    else:
        # Converti le probabilità in etichette binarie
        y_pred[y_pred > 0.5] = 1
        y_pred[y_pred <= 0.5] = 0
    
    # Binarizza le etichette per il calcolo OvR (one-vs-rest)
    y_true_bin = label_binarize(y_true, classes=np.unique(y_true))
    y_pred_bin = label_binarize(y_pred, classes=np.unique(y_true))
    
    precision = dict()
    recall = dict()
    for i in range(y_true_bin.shape[1]):
        precision[i], recall[i], _ = metrics.precision_recall_curve(y_true_bin[:, i], y_pred_bin[:, i])
    
    # Calcola l'AUPRC per ogni classe e poi la media
    auc_prc = np.mean([metrics.auc(recall[i], precision[i]) for i in range(y_true_bin.shape[1])])
    
    return auc_prc

def calc_AUC(y_true, y_pred):
    if not FLAGS.sigmoid:
        # Converti le etichette one-hot encoded in indici di classe
        y_true = np.argmax(y_true, axis=1)
        y_pred = np.argmax(y_pred, axis=1)
    else:
        # Converti le probabilità in etichette binarie
        y_pred[y_pred > 0.5] = 1
        y_pred[y_pred <= 0.5] = 0
    
    # Binarizza le etichette per il calcolo OvR (one-vs-rest)
    y_true_bin = label_binarize(y_true, classes=np.unique(y_true))
    y_pred_bin = label_binarize(y_pred, classes=np.unique(y_true))
    
    fpr = dict()
    tpr = dict()
    for i in range(y_true_bin.shape[1]):
        fpr[i], tpr[i], _ = metrics.roc_curve(y_true_bin[:, i], y_pred_bin[:, i])
    
    # Calcola l'AUC per ogni classe e poi la media
    auc_roc = np.mean([metrics.auc(fpr[i], tpr[i]) for i in range(y_true_bin.shape[1])])
    
    return auc_roc
scaricarare il dataset brca +

preprocessing di brca +
	cambiare informazioni cliniche da visualizzare (per i fenotipi? che indicano quali campioni rimuovere in base alle informazioni mancanti) +
							(fenotipi lasciati uguali all'originale)
	aggiungere seed 42 alla funzione cvTrait (dentro la funzione in preprocess_function) +
	knn +
	controllare sia il numero di pazienti che le features +
		il numero di features dei processati controllate aprendo il file Rdata su R (con load()) e per mRNA e miRNA controllare il numero di righe di datExp, per le altre il numero di colonne. Il numero di features degli estratti e il numero dei pazienti controllare la matrice (n x m) che esce fuori con knn, n->n_feature m->n_pazienti
	
	righe x colonne 
miRNA: features x pazienti DA TRASPORRE
DNAm: pazienti x features
mRNA: features x pazienti DA TRASPORRE
	devo estrapolare i topgenes (indici) dai dataexpr per poi usare snf. il numero di topgeni sono le feature estratte, il numero di righe di dataexpr sono invece le feature processate (per i mirNA, per dnam è il contrario). quindi l'idea è transporre le matrici che vanno transposte, andare a filtrare solo le features indicate dagli indici di topgene e poi usare snf. 
	problemi: se faccio una transposta, l'indice cambia? soluzione: per andare sul sicuro posso prima filtrare i topgene, per poi transporre la matrice
capire anche perchè nella shape le colonne vanno a +1, mentre le righe no 
	poi usare i datexpr nel mio snf, delle omiche usate nella tabella del paper (quella evidenziata) +
	
	preprocessing: dat expr vanno presi solo i top genes +
		per salvare il file txt dei topgenes ho usato questa riga: write.table(top_genes, "raw/top_genes.txt", row.names = FALSE, col.names = FALSE) # dopo aver load(.rds)
		se uso già i topgeni, inutile fare rsvd? per ora non ho usato rsvd 

	creazione dei dati di input: +
		innanzitutto ho unito i tre file meta mantenendo solo i pazienti in comune. -> sono 696 pazienti, il paper ne contava 698.
			L'altro numero (1083) considera tutti i pazienti e non solo quelli in comune nei tre file.
			devo far in modo che per ogni paziente salvi solo una volta le categorical column e la label, e non salvi le restanti colonne 
		filtrare e unire i file
		considerare l'attributo dell'età diviso in decade
		gestire gli NA -> nel file c'erano siano 'not reported' che 'nan', sono diventati tutti 'nan'. I valori vuoti diventeranno 'nan'
		codifica one hot sulle features. si creano molti elementi per via della features sull'età della diagniosi.
		codifica one hot delle label.
		creazione id map e class map
		creazione grafo g 
			controllato che ogni nodo abbia le giuste features e label +
		

	usare graphsage:
		segnare anche le tempistiche
	
		prima cosa è come impostare ora le flag sul training supervisionato in modo efficiente. devo capire quali vengono usati su mogdx probabilmente, per prendere spunto
		cosa fare: su mogdx calcola 2 metriche: accuracy e f1_score. graphsage invece calcola la loss, l'f1 score micro e macro. la cosa più logica da fare per un confronto è andare a calcolare le stesse metriche di mogdx. 
		altra cosa che mi chiedo è: ma su mogdx, quei valori, si riferiscono a training, validazione o test? inoltre avendo cambiato i dati, vanno bene lo stesso le percentuali che uso per dividere questi set? -> ho cambiato per come vengono splittati su mogdx


		gestione degli archi pesati: 		
		creazione grafo g da mogdx con snf.to.graph
			ho creato il grafo solo coi collegamenti con snf.to.graph di mogdx
			questo grafo devo convertirlo nel grafo che deve essere utilizzato da graphsage aggiungendo label, features (entrambi one hot) e poi le etichette per il val e test
				in graphsage-input-generator ho ordinato gli id in ordine alfabetico così da risultare coerente col grafo csv
			capire se e come rimuovere le colonne color dei grafi creati su mogdx

		
		in pratica sono 2 esperimenti: 1) quello che stai facendo adesso, ciò ti calcoli le matrici di similarità con affinity graph e usi SNF di python per integrare. Poi usi 		snf.to.graph per sparsificare. 2) usi la pipeli di mogdx cioè basta che fai girare knn_to_graph.R + SNF.R, cioè gli script già disponibili.
		nel secondo però devi vedere appunto come usare solo i 696 pazienti in comune
		la differenza sta in come vengono create le matrici di affinità delle singole omiche. Nel primo caso usi la solita scaled exponential e poi integri
		snel secondo caso usi similarità differenti e sparsifichi anche le singole omiche, non solo quella integrata
		la mia idea è che confrontando l exp 2 va mogdx, siccome usiamo la stessa costruzione del grafo integrato, ci permette meglio di capire se graphsage+clinica è meglio di gcn-mme (che è la gnn di mogdx)
			
******da fare: matrice di confusione (per quanto dice il paper di mogdx, dovrebbe essere la normal-type),Dobbiamo sapere quanti campioni abbiamo in ogni classe, 
	 aggiungere metriche "weighted F1"+ e "accuracy"+  e plot di val+ e test(no possibile lo calcola solo alla fine dell'ottimizzazione), ++

Totale di pazienti per ogni label:
LumA      394
LumB      125
Basal     104
Her2       43
Normal     30

matrice di confusione:
	Basal	Her2	LumA	LumB	Normal
Basal	21	0	0	0	0
Her2	0	7	2	0	0
LumA	0	0	79	0	0
LumB	0	1	23	1	0
Normal	1	0	5	0	0


stato dell'arte: altri lavori che fanno una cosa simili a quello che sto facendo io
		
	


leggere paper di MOGONET e MoGCN: controllare se i risultati sono gli stessi o quelli di mogdx li hanno fatti rigirare (tabella 2)

leggere file doc di jessica dove indica le criticità del preprocessing



riordinare appunti in ordine di creazione - aggiungere numerino tipo capitoli
cambiare i requirements su github
sul git manca **MODIFICHE.md**, o comunque le modifiche al codice sia snf che graphsage che mogdx
	snf: cercare 'modifiche' sul file versioneer.py (sul server non è servito)
	utils (graphsage). riga 70
	anche su mogdx ci sono delle modifiche *****

 

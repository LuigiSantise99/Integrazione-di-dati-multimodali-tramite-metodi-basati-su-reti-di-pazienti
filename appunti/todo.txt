scaricarare il dataset brca +

preprocessing di brca +
	girato il codice Preprocessing.R fornito da mogdx: Ogni sezione del codice segue una struttura simile per ogni omica, in cui si caricano i dati, si puliscono e si preparano per l'analisi differenziale, e infine si esegue l'analisi per determinare le variabili di interesse.
	Generazione del Meta File 
		* Meta data extraction: La prima parte del codice si occupa della generazione di un file di metadati contenente informazioni sui pazienti come race, gender, ethnicity, age_at_diagnosis, e una caratteristica target (trait), che potrebbe essere una delle classi cliniche o sottotipi di cancro.
		* Filtraggio: Si rimuovono le righe con valori mancanti per il tratto target (trait), e si eliminano i duplicati. Questo è un passaggio fondamentale per garantire che ogni paziente abbia solo una riga di metadati per ciascun tratto.
		* Salvataggio: I metadati vengono salvati in un file CSV per un successivo utilizzo.
	Preprocessing mRNA
		* Caricamento dei dati di espressione genica (mRNA): Vengono caricati i dati di espressione genica mRNA da un file .rda che contiene una matrice di conteggi dei geni.
   		* Filtraggio delle colonne duplicate: Si rimuovono le colonne duplicate basate sui nomi delle colonne (ossia, pazienti duplicati).
		* Intersezione con i metadati: Si identificano le colonne comuni tra i dati di espressione mRNA e il file di metadati e si mantengono solo le colonne corrispondenti.
		* Analisi dell'espressione differenziale: Si esegue un'analisi dell'espressione differenziale per trovare i geni significativamente espressi associati al tratto (trait), selezionando i primi 500 geni più significativi.
  		* Salvataggio dei risultati: I risultati dell'analisi vengono salvati in un file .RData che contiene i dati espressi, i metadati aggiornati, e i geni significativi.
	Preprocessing miRNA
		*Caricamento dei dati di espressione miRNA: I dati di espressione miRNA vengono caricati da un file .rda.
		*Estrazione dei conteggi: Viene costruita una matrice che separa i dati di conteggio e i dati normalizzati (letture per milione).
		*Intersezione con i metadati: Come nel caso mRNA, si ottiene l'intersezione tra i dati miRNA e i metadati per mantenere solo i campioni comuni.
		*Analisi dell'espressione differenziale: Si esegue un'analisi dell'espressione differenziale per i miRNA, selezionando i 200 miRNA più significativi.
		*Salvataggio dei risultati: I risultati dell'analisi, tra cui i dati espressi e i miRNA significativi, vengono salvati in un file .RData.
	Preprocessing DNAm (Metilazione del DNA)
		*Caricamento dei dati di metilazione: I dati di metilazione del DNA vengono caricati da un file .rda.
		*Filtraggio dei dati: Si rimuovono i siti CpG con valori mancanti (tramite la funzione complete.cases()), mantenendo solo i siti di metilazione completi.
		*Selezione dei siti CpG variabili: Viene calcolata la varianza di metilazione per ogni sito CpG e vengono selezionati i 200.000 siti più variabili.
		*Intersezione con i metadati: Si eseguono operazioni simili al mRNA e miRNA per allineare i dati di metilazione con i metadati, mantenendo solo i campioni comuni.
		*Analisi dell'associazione tra CpG e fenotipi: Si esegue una regressione Lasso (usando la funzione cvTrait) per identificare i siti CpG più associati al tratto di interesse (trait), usando una validazione incrociata con 10 fold.
			+ all'interno usa la funzione cvTrait (usata in dnam) (che è definita in preprocess_function), in cui si è aggiunto/modificato il seed 42 per migliorare la gestione della riproducibilità dei risultati e che quindi le operazioni stocastiche all'interno della funzione siano controllate e riproducibili.
		*Salvataggio dei risultati: I risultati finali, tra cui i siti CpG selezionati, i dati espressi e i metadati, vengono salvati in un file .RData.
	In Sintesi:
		*Pulizia e preparazione: Per ciascun tipo di dato omico (mRNA, miRNA, DNAm), i dati vengono ripuliti da duplicati e valori mancanti.
		*Intersezione con i metadati: Per garantire che i dati siano correttamente associati ai pazienti e ai tratti, si esegue un'operazione di intersezione tra i dati omici e i metadati, mantenendo solo i campioni comuni.
		*Analisi differenziale: Si eseguono analisi differenziali per identificare i geni, miRNA o siti CpG più significativi associati ai tratti di interesse, utilizzando tecniche statistiche come l'analisi dell'espressione differenziale e la regressione Lasso.
		*Salvataggio dei risultati: I risultati vengono infine salvati in file per un uso successivo, come la modellizzazione predittiva o l'interpretazione biologica.
	Ogni passaggio è fondamentale per preparare i dati in modo che possano essere utilizzati in modelli predittivi o analisi statistiche, garantendo che ogni modalità omica sia trattata adeguatamente prima dell'analisi finale.

	knn_graph_generation.R: vengono calcolati i datmeta, datexpr e graph. Ci sono due vie, in base all'esperimento che si sta effettuando. 
		*Per i primi due esperimenti si usa la funzione expr.to.graph (originale dal preprocessing di mogdx) e make.knn.graph:  progettate per costruire un grafo a partire da un dataset di espressione genica, di una delle modalità omiche, utilizzando una tecnica basata sui vicini più prossimi (K-Nearest Neighbors, KNN) e successivamente visualizzare e analizzare la relazione tra i campioni. (ci sono dei plot che posso creare e mettere come immagini, plot.igraph)
			+ make.knn.graph(D, k): Questa funzione crea un grafo utilizzando un algoritmo K-Nearest Neighbors (KNN) per identificare le relazioni di vicinanza tra i campioni (celle), tramite il calcolo delle distanze euclidee. k=15
			+ expr.to.graph: Questa funzione costruisce un grafo basato sull'espressione differenziale dei dati, utilizzando il concetto di correlazione tra le espressioni geniche (o altre feature) come base per definire le connessioni tra i campioni. A seconda della modalità omica (modality), la funzione seleziona la matrice di espressione appropriata, Se la modalità è mRNA o miRNA, viene selezionato un sottoinsieme di geni top (top_genes) dalle righe di datExpr. Se la modalità è differente, come DNAm, viene utilizzata la trasposizione di datExpr con le colonne corrispondenti ai geni top per il tratto (trait). Avviene anche una normalizzazione: la matrice viene centrata (le medie vengono sottratte da ciascuna riga). Questo passaggio è importante per rimuovere eventuali bias derivanti da valori di espressione più alti o più bassi tra i campioni, La correlazione riflette la somiglianza tra i campioni, ed è utilizzata per determinare la relazione tra i campioni stessi. infine viene ripulito da loop e edge multipli e avviene un etichettatura dei nodi (nome e tratto)
		* Per il terzo esperimento la funzione expr.to.graph è stata modificata. Normalizzazione Min-Max: La normalizzazione min-max viene applicata alla matrice di espressione per riportare i valori all'interno di un intervallo [0, 1]. Questo è utile per evitare che le caratteristiche con scale diverse (ad esempio, alcune variabili possono avere valori molto più grandi o piccoli di altre) influenzino in modo sproporzionato la costruzione del grafo. Questa normalizzazione è applicata solo alle modalità mRNA e miRNA, mentre per DNAm si presume che i valori siano già normalizzati nell'intervallo [0, 1], quindi non viene applicata alcuna modifica. Dopo la normalizzazione, la funzione seleziona le 500 feature (espressioni geniche, miRNA, o altre caratteristiche) con la maggiore variabilità, calcolata sulla base della deviazione standard di ciascuna riga della matrice di espressione. Questo passo è importante per ridurre la dimensionalità del dataset, concentrandosi solo sulle variabili che mostrano la maggiore variazione, che sono più probabili di essere informative per l'analisi. quindi viene creata una matrice di correlazione tra le feature selezionate e segue il procedimento della funzione originale.

	primo esperimento (in questo esperimento non è stato usato il grafo fornito da expr.to.graph descritto prima): su python sono state create matrici di affinità unimodali (partendo dai datExpr per ogni modalità omica) per poi fonderle in un'unica matrice di affinità fusa. più nel dettaglio: sono stati caricati i nomi dei migliori siti CpG (per la metilazione del DNA) e dei migliori geni per miRNA e mRNA. Questi sono usati per ridurre i dati alle caratteristiche più rilevanti. Filtrare i dataframe per mantenere solo i campioni che sono presenti in tutte e tre le modalità omiche. Questo è un passo cruciale quando si combinano dati da fonti diverse.  Creare matrici di affinità per ciascuna modalità omica utilizzando il metodo make_affinity del pacchetto snf (Similarity Network Fusion). La funzione calcola le somiglianze (affinità) tra i campioni usando la distanza euclidea. Le affinità vengono poi normalizzate e vengono mantenuti solo i 15 vicini più prossimi (K=15) per ogni campione. Combinare le matrici di affinità di tutte e tre le modalità omiche in una singola matrice di affinità fusa. Il metodo snf utilizza un algoritmo di fusione per combinare le informazioni provenienti da diverse fonti di dati (omic). a questo punto viene usato una funzione in R (fornito dal preprocessing di mogdx) modificato per essere più affine all'obiettivo: Creare un grafo K-Nearest Neighbors (KNN) utilizzando la matrice di affinità W. La funzione make.knn.graph prende la matrice W e crea un grafo in cui ogni nodo è connesso ai suoi 15 vicini più prossimi, basandosi sulle affinità calcolate nella matrice. L'algoritmo KNN crea un grafo in cui le connessioni tra i nodi rappresentano le somiglianze tra i campioni, e K=15 indica che ogni nodo è connesso ai 15 nodi più simili. c'è anche la rimozione di "autolink" o "self-loops" dalla matrice di affinità W (creata nel passaggio precedente). Gli autolink sono quelli in cui un nodo è connesso a se stesso, e nel contesto di SNF questi hanno un valore di 0.5. anche Rimozione dei Nodi Isolati,  i nodi che non hanno connessioni. in più vengono assegnati i nomi dei campioni ai nodi.

	secondo esperimento: in questo esperimento invece sono stati usati i grafi prodotti dalla knn descritta sopra (quindi quella fornita da mogdx). Seguendo quindi la pipeline del preprocessing di mogdx: in modo tale da combinare le informazioni di affinità da diverse fonti (modalità) utilizzando il metodo Similarity Network Fusion (SNF), e successivamente generare un grafo. Nel dettaglio: Allineamento dei pazienti comuni: Per ciascuna modalità, il codice trova l'intersezione tra i pazienti presenti nei metadati di tutte le modalità. Questo è essenziale per garantire che i dati provenienti da modalità diverse siano confrontabili, poiché i grafi devono essere costruiti utilizzando gli stessi campioni (696 campioni).  vengono usati quindi i grafi che rappresentano le relazioni di similarità tra i pazienti. Per ogni rete di similarità, viene creato un grafo utilizzando graph_from_data_frame, in cui le connessioni (edges) rappresentano le relazioni di similarità tra pazienti. I nodi rappresentano i pazienti, e le connessioni sono semplificate rimuovendo i loop e gli edge multipli tramite simplify(). La matrice di affinità per ciascun grafo viene estratta utilizzando as_adjacency_matrix. Ogni matrice di affinità rappresenta le connessioni (similarità) tra i pazienti in quel particolare grafo. Viene poi selezionato un sottoinsieme di pazienti comuni, assicurando che tutte le matrici abbiano la stessa dimensione e gli stessi pazienti. Fusione tramite SNF: Le matrici di affinità (ottenute dalle modalità omiche) vengono fuse usando l'algoritmo SNF (Similarity Network Fusion), implementato nel pacchetto SNFtool. L'algoritmo combina le informazioni di affinità provenienti dalle diverse modalità, creando una matrice di affinità fusa che integra le relazioni di similarità tra i pazienti da tutte le modalità. La funzione SNF prende le matrici di affinità, il numero di vicini (K=15) e il numero di iterazioni (T=10) per calcolare la fusione. rimuovendo anche gli autolink.  La matrice di affinità fusa (W) viene quindi utilizzata per creare un grafo finale con La funzione snf.to.graph: creando un grafo in cui ogni nodo (paziente) è connesso ai suoi 15 vicini più prossimi, basandosi sulla matrice di affinità. Il parametro K=15 indica che ogni nodo è connesso ai 15 nodi più simili, in termini di affinità, il grafo viene visualizzato come plot.pdf, rimozione dei nodi isolati e assegnazioni di attributi ai nodi, come i nomi dei campioni.

	SNF.R -> imposto modalities in base alle omiche che voglio considerare. Viene creato il grafo csv considerando la matrice di affinità fusa. (codice modificato per mantenere solo i pazienti in comune (696))
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (con features)
	addestrare modello supervisionato graphsage
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (senza features)
	addestrare modello supervisionato graphsage


	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (con features)
	addestrare modello supervisionato graphsage
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (senza features)
	addestrare modello supervisionato graphsage






//(controllare sia il numero di pazienti che le features. come ho fatto? il numero di features dei processati controllate aprendo il file Rdata su R (con load()) e per mRNA e miRNA controllare il numero di righe di datExp, per le altre il numero di colonne. Il numero di features degli estratti e il numero dei pazienti controllare la matrice (n x m) che esce fuori con knn, n->n_feature m->n_pazienti)
	
	righe x colonne 
miRNA: features x pazienti DA TRASPORRE
DNAm: pazienti x features
mRNA: features x pazienti DA TRASPORRE
	devo estrapolare i topgenes (indici) dai dataexpr per poi usare snf. il numero di topgeni sono le feature estratte, il numero di righe di dataexpr sono invece le feature processate (per i mirNA, per dnam è il contrario). quindi l'idea è transporre le matrici che vanno transposte, andare a filtrare solo le features indicate dagli indici di topgene e poi usare snf. 
	problemi: se faccio una transposta, l'indice cambia? soluzione: per andare sul sicuro posso prima filtrare i topgene, per poi transporre la matrice
capire anche perchè nella shape le colonne vanno a +1, mentre le righe no 
	poi usare i datexpr nel mio snf, delle omiche usate nella tabella del paper (quella evidenziata) +
	
	preprocessing: dat expr vanno presi solo i top genes +
		top genes: jessica: vengono calcolati con la differential expression e logistic regression
		per salvare il file txt dei topgenes ho usato questa riga: write.table(top_genes, "raw/top_genes.txt", row.names = FALSE, col.names = FALSE) # dopo aver load(.rds)
		se uso già i topgeni, inutile fare rsvd? 

	creazione dei dati di input: +
		innanzitutto ho unito i tre file meta mantenendo solo i pazienti in comune. -> sono 696 pazienti, il paper ne contava 698.
			L'altro numero (1083) considera tutti i pazienti e non solo quelli in comune nei tre file.
			devo far in modo che per ogni paziente salvi solo una volta le categorical column e la label, e non salvi le restanti colonne 
		filtrare e unire i file
		considerare l'attributo dell'età diviso in decade
		gestire gli NA -> nel file c'erano siano 'not reported' che 'nan', sono diventati tutti 'nan'. I valori vuoti diventeranno 'nan'
		codifica one hot sulle features. si creano molti elementi per via della features sull'età della diagniosi.
		codifica one hot delle label.
		creazione id map e class map
		creazione grafo g 
			controllato che ogni nodo abbia le giuste features e label +
			info da aggiungere alla tesi: 
			il codice esegue il training in modo trasduttivo. Questo significa che:

			Non crei due reti disgiunte per train e test:
			Tutti i nodi (inclusi quelli del test set) rimangono connessi nella stessa rete. Il grafo non viene suddiviso in due sottografi separati. In altre parole, i nodi nel 			test set possono essere vicini o connessi ai nodi nel train set.

			Divisione basata sulle label:
			Durante l'addestramento, il modello non utilizza le label dei nodi nel test set (i nodi con l'attributo test=True). Tuttavia, questi nodi rimangono parte del grafo e 			contribuiscono alla struttura topologica. I nodi di test possono influenzare l'addestramento del modello perché le informazioni di vicinato passano comunque 			attraverso di loro.

			L'attributo delle label nel test set:
			Nel test set, i nodi hanno ancora le loro etichette, ma queste non vengono utilizzate durante l'addestramento. Le label vengono utilizzate solo durante la fase di 			valutazione per calcolare le metriche.

			In breve: stai addestrando un modello trasduttivo, in cui:

			L'intero grafo (inclusi train, validation, e test) viene usato per costruire embedding dei nodi.
			Durante il training, solo i nodi del training set (non quelli di test) hanno le loro label visibili al modello.

			inoltre uso k-fold cv, con k=5
			info di jessica:
				https://scikit-learn.org/1.5/_images/grid_search_cross_validation.png
				lo si usa perchè lo usa anche mogdx, quindi per avere un confronto lineare e uguale
			
		

	usare graphsage:
		segnare anche le tempistiche
	
		prima cosa è come impostare ora le flag sul training supervisionato in modo efficiente. devo capire quali vengono usati su mogdx probabilmente, per prendere spunto
		cosa fare: su mogdx calcola 2 metriche: accuracy e f1_score. graphsage invece calcola la loss, l'f1 score micro e macro. la cosa più logica da fare per un confronto è andare a calcolare le stesse metriche di mogdx. 
		altra cosa che mi chiedo è: ma su mogdx, quei valori, si riferiscono a training, validazione o test? inoltre avendo cambiato i dati, vanno bene lo stesso le percentuali che uso per dividere questi set? -> ho cambiato per come vengono splittati su mogdx


		gestione degli archi pesati: 		
		creazione grafo g da mogdx con snf.to.graph (k impostato a 20 sia nella creazione della matrice di affinità, sia in mogdx)
			ho creato il grafo solo coi collegamenti con snf.to.graph di mogdx
			questo grafo devo convertirlo nel grafo che deve essere utilizzato da graphsage aggiungendo label, features (entrambi one hot) e poi le etichette per il val e test
				in graphsage-input-generator ho ordinato gli id in ordine alfabetico così da risultare coerente col grafo csv
			capire se e come rimuovere le colonne color dei grafi creati su mogdx

			

Totale di pazienti per ogni label:
Basal     104
Her2       43
LumA      394
LumB      125
Normal     30


stato dell'arte: altri lavori che fanno una cosa simili a quello che sto facendo io
		
	


leggere paper di MOGONET e MoGCN: controllare se i risultati sono gli stessi o quelli di mogdx li hanno fatti rigirare (tabella 2)

leggere file doc di jessica dove indica le criticità del preprocessing
capire se la libreria future è un problea durante l'adesramento, e i messaggi di warning quando snfpy in affinity-matrix.py


riordinare appunti in ordine di creazione - aggiungere numerino tipo capitoli
cambiare i requirements su github
sul git manca **MODIFICHE.md**, o comunque le modifiche al codice sia snf che graphsage che mogdx
	snf: cercare 'modifiche' sul file versioneer.py (sul server non è servito)
	utils (graphsage). riga 70
	anche su mogdx ci sono delle modifiche *****
		seed in cvtrait
		aggiunta funzione snf.to.graphfromPy
		vedere sotto secondo esperimento > snf.r
		modifiche knn_graph_generation.R per terzo esperimento, controllo range



primo esperimento:
	knn_graph_generation.R -> per avere datexpr e datmeta per ogni omica. 
	affinity_matrix.py -> prende datExpr generati nella pipeline di mogdx e crea la matrice di affinità fusa con snfpy con l'aggiunta degli id dei pazienti per ogni riga/col
	graph_creation.R -> prende la matrice di affinità con id appena creata e crea il grafo con i vari collegamenti tra nodi, usa snf.to.graph.FromPy
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (con features)
	addestrare modello supervisionato graphsage
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (senza features)
	addestrare modello supervisionato graphsage


secondo esperimento:
	knn_graph_generation.R -> per avere grafo, datexpr e datmeta per ogni omica. (i grafi vanno poi spostati nella cartella MOGDx/Network/SNF)
	SNF.R -> imposto modalities in base alle omiche che voglio considerare. Viene creato il grafo csv considerando la matrice di affinità fusa. (codice modificato per mantenere solo i pazienti in comune (696))
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (con features)
	addestrare modello supervisionato graphsage
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (senza features)
	addestrare modello supervisionato graphsage


TEST_1 k=20 (la presentazione mostra tutti i risultati e le altri info del primo e secondo esperimento)
con k=15 è peggiorato solo il secondo exp, il resto è piu o meno uguale (considerando le medie e le deviazioni standard avendo usato k fold cv)



terzo esperimento: (usando il preprocessing di mogdx che sparsifica sia le matrici singole che quella finale)
praticamente per ogni variabile in ogni dataset (mirna, mrna, dnam) bisogna calcolare la deviazione standard, per poi prendere le prime 500 con deviazione piu alta
il problema è che il range di queste variabili può cambiare quindi vanno convertite ad un range che sia uguale per tutti questa cosa però va fatta solo con mirna e mrna (fare un check per la dnam ma dovrebbe avere già tutti i range uguali (0-1)).
quindi prima vanno controllati i range:
	+ viene fatto su knn_graph_generation.R, La modalità DNAm ha i pazienti sulle righe, quindi va trasposta per essere coerente con miRNA e mRNA, di seguito i range globali per ogni omica:
	mRNA: Range globale:  2.979922 23.16517
	miRNA: Range globale:  2.298648 21.88383
	DNAm: Range globale:  0.004157793 0.9960434
	conclusioni: DNAm non va toccata perchè ha già range [0-1], mentre mRNA e miRNA va convertita per far si che abbia range [0-1]
	
per la conversione mi pare che volesse usare min-max la prof per il controllo. 
Dovevi fare il boxplot per miRNA ed mRNA di massimo per ogni feature, minimo per ogni feature e min-max per ogni feature. quindi 3 boxplot per mirna e 3 per mrna:
	+ nella cartella di mogdx c'è il file Rplots.pdf che contiente i 3 boxplot per ogni omica (anche dnam ho messo)

Ti rispiego quale è il problema: nel pre-processing di mogdx la feature selection viene fatta usando la differential expression o la regressione logistica multinomiale
per fare sia l'espressione differenziale che la regression logistica. tu devi fornire le etichette dei dati, loro le hanno fornite tutte, comprese quelle del test set
ora, è vero che il modello viene addestrato in modo trasduttivo (quindi il modello nel training vede tutti gli archi del grafo) ma non può vedere le etichette
se nella feature selection gliele fai vedere hai quello che viene chiamato information leakage. Cioè delle informazioni del test set sono scivolate all'interno dell'addestramento
e questo di solito porta a delle metriche di predizione over-ottimiche, cioè migliori di quanto dovrebbero essere
noi vogliamo vedere se il nostro modello regge anche senza questo bias, quindi ci aspettiamo un piccolo abbassamento delle performance
	+ ho modificato il file knn_graph_generation.R e aggiunto la funzione expr.to.graph.fs che normalizza e seleziona le feature con migliore deviazione standard
	expr.to.graph: prende i datExpr e li usa per calcolare le matrici di similarità e per sparsificarle


terzo esperimento (procedimento):
	knn_graph_generation.R -> per avere grafo, datexpr e datmeta per ogni omica. (i grafi vanno poi spostati nella cartella MOGDx/Network/SNF). Diversamente dal secondo esperimento è stata modificato la funzione expr.to.graph per creare il grafo in maniera diversa 
	
	SNF.R -> imposto modalities in base alle omiche che voglio considerare. Viene creato il grafo csv considerando la matrice di affinità fusa. (codice modificato per mantenere solo i pazienti in comune (696))
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (con features)
	addestrare modello supervisionato graphsage
	graphsage_input_generator.py -> conversione grafo valido per graphsage + aggiunta feats, label e divisione in set + 5-fold cv (senza features)
	addestrare modello supervisionato graphsage

finito il terzo esperimento fare csv con:
	risultati dev standard exp1 con e senza features
	risultati dev standard exp2 con e senza features
	risultati dev standard exp3 con e senza features